{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlike arithmetic operators in C,"},{"type":"text","text":" "},{"type":"text","text":"arithmetic operators in Swift don’t overflow by default."},{"type":"text","text":" "},{"type":"text","text":"Overflow behavior is trapped and reported as an error."},{"type":"text","text":" "},{"type":"text","text":"To opt in to overflow behavior,"},{"type":"text","text":" "},{"type":"text","text":"use Swift’s second set of arithmetic operators that overflow by default,"},{"type":"text","text":" "},{"type":"text","text":"such as the overflow addition operator ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"All of these overflow operators begin with an ampersand ("},{"type":"codeVoice","code":"&"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you define your own structures, classes, and enumerations,"},{"type":"text","text":" "},{"type":"text","text":"it can be useful to provide your own implementations of"},{"type":"text","text":" "},{"type":"text","text":"the standard Swift operators for these custom types."},{"type":"text","text":" "},{"type":"text","text":"Swift makes it easy to provide tailored implementations of these operators"},{"type":"text","text":" "},{"type":"text","text":"and to determine exactly what their behavior should be for each type you create."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You’re not limited to the predefined operators."},{"type":"text","text":" "},{"type":"text","text":"Swift gives you the freedom to define your own custom"},{"type":"text","text":" "},{"type":"text","text":"infix, prefix, postfix, and assignment operators,"},{"type":"text","text":" "},{"type":"text","text":"with custom precedence and associativity values."},{"type":"text","text":" "},{"type":"text","text":"These operators can be used and adopted in your code like any of the predefined operators,"},{"type":"text","text":" "},{"type":"text","text":"and you can even extend existing types to support the custom operators you define."}]},{"anchor":"Bitwise-Operators","level":2,"type":"heading","text":"Bitwise Operators"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Bitwise operators"}]},{"type":"text","text":" enable you to manipulate"},{"type":"text","text":" "},{"type":"text","text":"the individual raw data bits within a data structure."},{"type":"text","text":" "},{"type":"text","text":"They’re often used in low-level programming,"},{"type":"text","text":" "},{"type":"text","text":"such as graphics programming and device driver creation."},{"type":"text","text":" "},{"type":"text","text":"Bitwise operators can also be useful when you work with raw data from external sources,"},{"type":"text","text":" "},{"type":"text","text":"such as encoding and decoding data for communication over a custom protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift supports all of the bitwise operators found in C, as described below."}]},{"anchor":"Bitwise-NOT-Operator","level":3,"type":"heading","text":"Bitwise NOT Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise NOT operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"~"},{"type":"text","text":") inverts all bits in a number:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseNOT"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bitwise NOT operator is a prefix operator,"},{"type":"text","text":" "},{"type":"text","text":"and appears immediately before the value it operates on,"},{"type":"text","text":" "},{"type":"text","text":"without any white space:"}]},{"type":"codeListing","syntax":"swift","code":["let initialBits: UInt8 = 0b00001111","let invertedBits = ~initialBits  \/\/ equals 11110000"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" integers have eight bits"},{"type":"text","text":" "},{"type":"text","text":"and can store any value between "},{"type":"codeVoice","code":"0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"255"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This example initializes a "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" integer with the binary value "},{"type":"codeVoice","code":"00001111"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which has its first four bits set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and its second four bits set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is equivalent to a decimal value of "},{"type":"codeVoice","code":"15"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bitwise NOT operator is then used to create a new constant called "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is equal to "},{"type":"codeVoice","code":"initialBits"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"but with all of the bits inverted."},{"type":"text","text":" "},{"type":"text","text":"Zeros become ones, and ones become zeros."},{"type":"text","text":" "},{"type":"text","text":"The value of "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":" is "},{"type":"codeVoice","code":"11110000"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is equal to an unsigned decimal value of "},{"type":"codeVoice","code":"240"},{"type":"text","text":"."}]},{"anchor":"Bitwise-AND-Operator","level":3,"type":"heading","text":"Bitwise AND Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise AND operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"&"},{"type":"text","text":") combines the bits of two numbers."},{"type":"text","text":" "},{"type":"text","text":"It returns a new number whose bits are set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"only if the bits were equal to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in "},{"type":"emphasis","inlineContent":[{"type":"text","text":"both"}]},{"type":"text","text":" input numbers:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseAND"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example below,"},{"type":"text","text":" "},{"type":"text","text":"the values of "},{"type":"codeVoice","code":"firstSixBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"lastSixBits"},{"type":"text","text":" "},{"type":"text","text":"both have four middle bits equal to "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The bitwise AND operator combines them to make the number "},{"type":"codeVoice","code":"00111100"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is equal to an unsigned decimal value of "},{"type":"codeVoice","code":"60"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let firstSixBits: UInt8 = 0b11111100","let lastSixBits: UInt8  = 0b00111111","let middleFourBits = firstSixBits & lastSixBits  \/\/ equals 00111100"]},{"anchor":"Bitwise-OR-Operator","level":3,"type":"heading","text":"Bitwise OR Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise OR operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"|"},{"type":"text","text":") compares the bits of two numbers."},{"type":"text","text":" "},{"type":"text","text":"The operator returns a new number whose bits are set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"if the bits are equal to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in "},{"type":"emphasis","inlineContent":[{"type":"text","text":"either"}]},{"type":"text","text":" input number:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseOR"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example below,"},{"type":"text","text":" "},{"type":"text","text":"the values of "},{"type":"codeVoice","code":"someBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"moreBits"},{"type":"text","text":" have different bits set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The bitwise OR operator combines them to make the number "},{"type":"codeVoice","code":"11111110"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which equals an unsigned decimal of "},{"type":"codeVoice","code":"254"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let someBits: UInt8 = 0b10110010","let moreBits: UInt8 = 0b01011110","let combinedbits = someBits | moreBits  \/\/ equals 11111110"]},{"anchor":"Bitwise-XOR-Operator","level":3,"type":"heading","text":"Bitwise XOR Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise XOR operator"}]},{"type":"text","text":", or “exclusive OR operator” ("},{"type":"codeVoice","code":"^"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"compares the bits of two numbers."},{"type":"text","text":" "},{"type":"text","text":"The operator returns a new number whose bits are set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"where the input bits are different"},{"type":"text","text":" "},{"type":"text","text":"and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" where the input bits are the same:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseXOR"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example below,"},{"type":"text","text":" "},{"type":"text","text":"the values of "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"otherBits"},{"type":"text","text":" each have a bit set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"in a location that the other does not."},{"type":"text","text":" "},{"type":"text","text":"The bitwise XOR operator sets both of these bits to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in its output value."},{"type":"text","text":" "},{"type":"text","text":"All of the other bits in "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"otherBits"},{"type":"text","text":" match"},{"type":"text","text":" "},{"type":"text","text":"and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" in the output value:"}]},{"type":"codeListing","syntax":"swift","code":["let firstBits: UInt8 = 0b00010100","let otherBits: UInt8 = 0b00000101","let outputBits = firstBits ^ otherBits  \/\/ equals 00010001"]},{"anchor":"Bitwise-Left-and-Right-Shift-Operators","level":3,"type":"heading","text":"Bitwise Left and Right Shift Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise left shift operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"<<"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise right shift operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":">>"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"move all bits in a number to the left or the right by a certain number of places,"},{"type":"text","text":" "},{"type":"text","text":"according to the rules defined below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Bitwise left and right shifts have the effect of"},{"type":"text","text":" "},{"type":"text","text":"multiplying or dividing an integer by a factor of two."},{"type":"text","text":" "},{"type":"text","text":"Shifting an integer’s bits to the left by one position doubles its value,"},{"type":"text","text":" "},{"type":"text","text":"whereas shifting it to the right by one position halves its value."}]},{"anchor":"Shifting-Behavior-for-Unsigned-Integers","level":4,"type":"heading","text":"Shifting Behavior for Unsigned Integers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bit-shifting behavior for unsigned integers is as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Existing bits are moved to the left or right by the requested number of places."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Any bits that are moved beyond the bounds of the integer’s storage are discarded."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Zeros are inserted in the spaces left behind"},{"type":"text","text":" "},{"type":"text","text":"after the original bits are moved to the left or right."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This approach is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"logical shift"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The illustration below shows the results of "},{"type":"codeVoice","code":"11111111 << 1"},{"type":"text","text":" "},{"type":"text","text":"(which is "},{"type":"codeVoice","code":"11111111"},{"type":"text","text":" shifted to the left by "},{"type":"codeVoice","code":"1"},{"type":"text","text":" place),"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"11111111 >> 1"},{"type":"text","text":" "},{"type":"text","text":"(which is "},{"type":"codeVoice","code":"11111111"},{"type":"text","text":" shifted to the right by "},{"type":"codeVoice","code":"1"},{"type":"text","text":" place)."},{"type":"text","text":" "},{"type":"text","text":"Blue numbers are shifted,"},{"type":"text","text":" "},{"type":"text","text":"gray numbers are discarded,"},{"type":"text","text":" "},{"type":"text","text":"and orange zeros are inserted:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftUnsigned"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how bit shifting looks in Swift code:"}]},{"type":"codeListing","syntax":"swift","code":["let shiftBits: UInt8 = 4   \/\/ 00000100 in binary","shiftBits << 1             \/\/ 00001000","shiftBits << 2             \/\/ 00010000","shiftBits << 5             \/\/ 10000000","shiftBits << 6             \/\/ 00000000","shiftBits >> 2             \/\/ 00000001"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use bit shifting to encode and decode values within other data types:"}]},{"type":"codeListing","syntax":"swift","code":["let pink: UInt32 = 0xCC6699","let redComponent = (pink & 0xFF0000) >> 16    \/\/ redComponent is 0xCC, or 204","let greenComponent = (pink & 0x00FF00) >> 8   \/\/ greenComponent is 0x66, or 102","let blueComponent = pink & 0x0000FF           \/\/ blueComponent is 0x99, or 153"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example uses a "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" constant called "},{"type":"codeVoice","code":"pink"},{"type":"text","text":" to store a"},{"type":"text","text":" "},{"type":"text","text":"Cascading Style Sheets color value for the color pink."},{"type":"text","text":" "},{"type":"text","text":"The CSS color value "},{"type":"codeVoice","code":"#CC6699"},{"type":"text","text":" is written as"},{"type":"text","text":" "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" in Swift’s hexadecimal number representation."},{"type":"text","text":" "},{"type":"text","text":"This color is then decomposed into its"},{"type":"text","text":" "},{"type":"text","text":"red ("},{"type":"codeVoice","code":"CC"},{"type":"text","text":"), green ("},{"type":"codeVoice","code":"66"},{"type":"text","text":"), and blue ("},{"type":"codeVoice","code":"99"},{"type":"text","text":") components"},{"type":"text","text":" "},{"type":"text","text":"by the bitwise AND operator ("},{"type":"codeVoice","code":"&"},{"type":"text","text":") and the bitwise right shift operator ("},{"type":"codeVoice","code":">>"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The red component is obtained by performing a bitwise AND"},{"type":"text","text":" "},{"type":"text","text":"between the numbers "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" and "},{"type":"codeVoice","code":"0xFF0000"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The zeros in "},{"type":"codeVoice","code":"0xFF0000"},{"type":"text","text":" effectively “mask” the second and third bytes of "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"causing the "},{"type":"codeVoice","code":"6699"},{"type":"text","text":" to be ignored and leaving "},{"type":"codeVoice","code":"0xCC0000"},{"type":"text","text":" as the result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This number is then shifted 16 places to the right ("},{"type":"codeVoice","code":">> 16"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Each pair of characters in a hexadecimal number uses 8 bits,"},{"type":"text","text":" "},{"type":"text","text":"so a move 16 places to the right will convert "},{"type":"codeVoice","code":"0xCC0000"},{"type":"text","text":" into "},{"type":"codeVoice","code":"0x0000CC"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is the same as "},{"type":"codeVoice","code":"0xCC"},{"type":"text","text":", which has a decimal value of "},{"type":"codeVoice","code":"204"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similarly, the green component is obtained by performing a bitwise AND"},{"type":"text","text":" "},{"type":"text","text":"between the numbers "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" and "},{"type":"codeVoice","code":"0x00FF00"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which gives an output value of "},{"type":"codeVoice","code":"0x006600"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This output value is then shifted eight places to the right,"},{"type":"text","text":" "},{"type":"text","text":"giving a value of "},{"type":"codeVoice","code":"0x66"},{"type":"text","text":", which has a decimal value of "},{"type":"codeVoice","code":"102"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, the blue component is obtained by performing a bitwise AND"},{"type":"text","text":" "},{"type":"text","text":"between the numbers "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" and "},{"type":"codeVoice","code":"0x0000FF"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which gives an output value of "},{"type":"codeVoice","code":"0x000099"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because "},{"type":"codeVoice","code":"0x000099"},{"type":"text","text":" already equals "},{"type":"codeVoice","code":"0x99"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which has a decimal value of "},{"type":"codeVoice","code":"153"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"this value is used without shifting it to the right,"}]},{"anchor":"Shifting-Behavior-for-Signed-Integers","level":4,"type":"heading","text":"Shifting Behavior for Signed Integers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The shifting behavior is more complex for signed integers than for unsigned integers,"},{"type":"text","text":" "},{"type":"text","text":"because of the way signed integers are represented in binary."},{"type":"text","text":" "},{"type":"text","text":"(The examples below are based on 8-bit signed integers for simplicity,"},{"type":"text","text":" "},{"type":"text","text":"but the same principles apply for signed integers of any size.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Signed integers use their first bit (known as the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"sign bit"}]},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"to indicate whether the integer is positive or negative."},{"type":"text","text":" "},{"type":"text","text":"A sign bit of "},{"type":"codeVoice","code":"0"},{"type":"text","text":" means positive, and a sign bit of "},{"type":"codeVoice","code":"1"},{"type":"text","text":" means negative."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The remaining bits (known as the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value bits"}]},{"type":"text","text":") store the actual value."},{"type":"text","text":" "},{"type":"text","text":"Positive numbers are stored in exactly the same way as for unsigned integers,"},{"type":"text","text":" "},{"type":"text","text":"counting upwards from "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Here’s how the bits inside an "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" look for the number "},{"type":"codeVoice","code":"4"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedFour"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The sign bit is "},{"type":"codeVoice","code":"0"},{"type":"text","text":" (meaning “positive”),"},{"type":"text","text":" "},{"type":"text","text":"and the seven value bits are just the number "},{"type":"codeVoice","code":"4"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"written in binary notation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Negative numbers, however, are stored differently."},{"type":"text","text":" "},{"type":"text","text":"They’re stored by subtracting their absolute value from "},{"type":"codeVoice","code":"2"},{"type":"text","text":" to the power of "},{"type":"codeVoice","code":"n"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"type":"codeVoice","code":"n"},{"type":"text","text":" is the number of value bits."},{"type":"text","text":" "},{"type":"text","text":"An eight-bit number has seven value bits,"},{"type":"text","text":" "},{"type":"text","text":"so this means "},{"type":"codeVoice","code":"2"},{"type":"text","text":" to the power of "},{"type":"codeVoice","code":"7"},{"type":"text","text":", or "},{"type":"codeVoice","code":"128"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the bits inside an "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" look for the number "},{"type":"codeVoice","code":"-4"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFour"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This time, the sign bit is "},{"type":"codeVoice","code":"1"},{"type":"text","text":" (meaning “negative”),"},{"type":"text","text":" "},{"type":"text","text":"and the seven value bits have a binary value of "},{"type":"codeVoice","code":"124"},{"type":"text","text":" (which is "},{"type":"codeVoice","code":"128 - 4"},{"type":"text","text":"):"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFourValue"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This encoding for negative numbers is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"two’s complement"}]},{"type":"text","text":" representation."},{"type":"text","text":" "},{"type":"text","text":"It may seem an unusual way to represent negative numbers,"},{"type":"text","text":" "},{"type":"text","text":"but it has several advantages."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, you can add "},{"type":"codeVoice","code":"-1"},{"type":"text","text":" to "},{"type":"codeVoice","code":"-4"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"simply by performing a standard binary addition of all eight bits"},{"type":"text","text":" "},{"type":"text","text":"(including the sign bit),"},{"type":"text","text":" "},{"type":"text","text":"and discarding anything that doesn’t fit in the eight bits once you’re done:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedAddition"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Second, the two’s complement representation also lets you"},{"type":"text","text":" "},{"type":"text","text":"shift the bits of negative numbers to the left and right like positive numbers,"},{"type":"text","text":" "},{"type":"text","text":"and still end up doubling them for every shift you make to the left,"},{"type":"text","text":" "},{"type":"text","text":"or halving them for every shift you make to the right."},{"type":"text","text":" "},{"type":"text","text":"To achieve this, an extra rule is used when signed integers are shifted to the right:"},{"type":"text","text":" "},{"type":"text","text":"When you shift signed integers to the right,"},{"type":"text","text":" "},{"type":"text","text":"apply the same rules as for unsigned integers,"},{"type":"text","text":" "},{"type":"text","text":"but fill any empty bits on the left with the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"sign bit"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"rather than with a zero."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSigned"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This action ensures that signed integers have the same sign after they’re shifted to the right,"},{"type":"text","text":" "},{"type":"text","text":"and is known as an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"arithmetic shift"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of the special way that positive and negative numbers are stored,"},{"type":"text","text":" "},{"type":"text","text":"shifting either of them to the right moves them closer to zero."},{"type":"text","text":" "},{"type":"text","text":"Keeping the sign bit the same during this shift means that"},{"type":"text","text":" "},{"type":"text","text":"negative integers remain negative as their value moves closer to zero."}]},{"anchor":"Overflow-Operators","level":2,"type":"heading","text":"Overflow Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you try to insert a number into an integer constant or variable"},{"type":"text","text":" "},{"type":"text","text":"that can’t hold that value,"},{"type":"text","text":" "},{"type":"text","text":"by default Swift reports an error rather than allowing an invalid value to be created."},{"type":"text","text":" "},{"type":"text","text":"This behavior gives extra safety when you work with numbers that are too large or too small."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" integer type can hold"},{"type":"text","text":" "},{"type":"text","text":"any signed integer between "},{"type":"codeVoice","code":"-32768"},{"type":"text","text":" and "},{"type":"codeVoice","code":"32767"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Trying to set an "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" constant or variable to a number outside of this range"},{"type":"text","text":" "},{"type":"text","text":"causes an error:"}]},{"type":"codeListing","syntax":"swift","code":["var potentialOverflow = Int16.max","\/\/ potentialOverflow equals 32767, which is the maximum value an Int16 can hold","potentialOverflow += 1","\/\/ this causes an error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Providing error handling when values get too large or too small"},{"type":"text","text":" "},{"type":"text","text":"gives you much more flexibility when coding for boundary value conditions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, when you specifically want an overflow condition"},{"type":"text","text":" "},{"type":"text","text":"to truncate the number of available bits,"},{"type":"text","text":" "},{"type":"text","text":"you can opt in to this behavior rather than triggering an error."},{"type":"text","text":" "},{"type":"text","text":"Swift provides three arithmetic "},{"type":"emphasis","inlineContent":[{"type":"text","text":"overflow operators"}]},{"type":"text","text":" that opt in to"},{"type":"text","text":" "},{"type":"text","text":"the overflow behavior for integer calculations."},{"type":"text","text":" "},{"type":"text","text":"These operators all begin with an ampersand ("},{"type":"codeVoice","code":"&"},{"type":"text","text":"):"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow addition ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow subtraction ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow multiplication ("},{"type":"codeVoice","code":"&*"},{"type":"text","text":")"}]}]}]},{"anchor":"Value-Overflow","level":3,"type":"heading","text":"Value Overflow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Numbers can overflow in both the positive and negative direction."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of what happens when"},{"type":"text","text":" "},{"type":"text","text":"an unsigned integer is allowed to overflow in the positive direction,"},{"type":"text","text":" "},{"type":"text","text":"using the overflow addition operator ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":"):"}]},{"type":"codeListing","syntax":"swift","code":["var unsignedOverflow = UInt8.max","\/\/ unsignedOverflow equals 255, which is the maximum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &+ 1","\/\/ unsignedOverflow is now equal to 0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The variable "},{"type":"codeVoice","code":"unsignedOverflow"},{"type":"text","text":" is initialized with the maximum value a "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" can hold"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"255"},{"type":"text","text":", or "},{"type":"codeVoice","code":"11111111"},{"type":"text","text":" in binary)."},{"type":"text","text":" "},{"type":"text","text":"It’s then incremented by "},{"type":"codeVoice","code":"1"},{"type":"text","text":" using the overflow addition operator ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"This pushes its binary representation just over the size that a "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" can hold,"},{"type":"text","text":" "},{"type":"text","text":"causing it to overflow beyond its bounds,"},{"type":"text","text":" "},{"type":"text","text":"as shown in the diagram below."},{"type":"text","text":" "},{"type":"text","text":"The value that remains within the bounds of the "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" "},{"type":"text","text":"after the overflow addition is "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":", or zero."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowAddition"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Something similar happens when"},{"type":"text","text":" "},{"type":"text","text":"an unsigned integer is allowed to overflow in the negative direction."},{"type":"text","text":" "},{"type":"text","text":"Here’s an example using the overflow subtraction operator ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":"):"}]},{"type":"codeListing","syntax":"swift","code":["var unsignedOverflow = UInt8.min","\/\/ unsignedOverflow equals 0, which is the minimum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &- 1","\/\/ unsignedOverflow is now equal to 255"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The minimum value that a "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" can hold is zero,"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":" in binary."},{"type":"text","text":" "},{"type":"text","text":"If you subtract "},{"type":"codeVoice","code":"1"},{"type":"text","text":" from "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":" using the overflow subtraction operator ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"the number will overflow and wrap around to "},{"type":"codeVoice","code":"11111111"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"255"},{"type":"text","text":" in decimal."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowUnsignedSubtraction"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow also occurs for signed integers."},{"type":"text","text":" "},{"type":"text","text":"All addition and subtraction for signed integers is performed in bitwise fashion,"},{"type":"text","text":" "},{"type":"text","text":"with the sign bit included as part of the numbers being added or subtracted,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["var signedOverflow = Int8.min","\/\/ signedOverflow equals -128, which is the minimum value an Int8 can hold","signedOverflow = signedOverflow &- 1","\/\/ signedOverflow is now equal to 127"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The minimum value that an "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" can hold is "},{"type":"codeVoice","code":"-128"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"10000000"},{"type":"text","text":" in binary."},{"type":"text","text":" "},{"type":"text","text":"Subtracting "},{"type":"codeVoice","code":"1"},{"type":"text","text":" from this binary number with the overflow operator"},{"type":"text","text":" "},{"type":"text","text":"gives a binary value of "},{"type":"codeVoice","code":"01111111"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which toggles the sign bit and gives positive "},{"type":"codeVoice","code":"127"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the maximum positive value that an "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" can hold."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowSignedSubtraction"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For both signed and unsigned integers,"},{"type":"text","text":" "},{"type":"text","text":"overflow in the positive direction"},{"type":"text","text":" "},{"type":"text","text":"wraps around from the maximum valid integer value back to the minimum,"},{"type":"text","text":" "},{"type":"text","text":"and overflow in the negative direction"},{"type":"text","text":" "},{"type":"text","text":"wraps around from the minimum value to the maximum."}]},{"anchor":"Precedence-and-Associativity","level":2,"type":"heading","text":"Precedence and Associativity"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Operator "},{"type":"emphasis","inlineContent":[{"type":"text","text":"precedence"}]},{"type":"text","text":" gives some operators higher priority than others;"},{"type":"text","text":" "},{"type":"text","text":"these operators are applied first."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Operator "},{"type":"emphasis","inlineContent":[{"type":"text","text":"associativity"}]},{"type":"text","text":" defines how operators of the same precedence"},{"type":"text","text":" "},{"type":"text","text":"are grouped together —"},{"type":"text","text":" "},{"type":"text","text":"either grouped from the left, or grouped from the right."},{"type":"text","text":" "},{"type":"text","text":"Think of it as meaning “they associate with the expression to their left,”"},{"type":"text","text":" "},{"type":"text","text":"or “they associate with the expression to their right.”"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s important to consider"},{"type":"text","text":" "},{"type":"text","text":"each operator’s precedence and associativity"},{"type":"text","text":" "},{"type":"text","text":"when working out the order in which a compound expression will be calculated."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"operator precedence explains why the following expression equals "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["2 + 3 % 4 * 5","\/\/ this equals 17"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you read strictly from left to right,"},{"type":"text","text":" "},{"type":"text","text":"you might expect the expression to be calculated as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"2"},{"type":"text","text":" plus "},{"type":"codeVoice","code":"3"},{"type":"text","text":" equals "},{"type":"codeVoice","code":"5"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"5"},{"type":"text","text":" remainder "},{"type":"codeVoice","code":"4"},{"type":"text","text":" equals "},{"type":"codeVoice","code":"1"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"1"},{"type":"text","text":" times "},{"type":"codeVoice","code":"5"},{"type":"text","text":" equals "},{"type":"codeVoice","code":"5"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, the actual answer is "},{"type":"codeVoice","code":"17"},{"type":"text","text":", not "},{"type":"codeVoice","code":"5"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Higher-precedence operators are evaluated before lower-precedence ones."},{"type":"text","text":" "},{"type":"text","text":"In Swift, as in C,"},{"type":"text","text":" "},{"type":"text","text":"the remainder operator ("},{"type":"codeVoice","code":"%"},{"type":"text","text":") and the multiplication operator ("},{"type":"codeVoice","code":"*"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"have a higher precedence than the addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"As a result, they’re both evaluated before the addition is considered."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, remainder and multiplication have the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"same"}]},{"type":"text","text":" precedence as each other."},{"type":"text","text":" "},{"type":"text","text":"To work out the exact evaluation order to use,"},{"type":"text","text":" "},{"type":"text","text":"you also need to consider their associativity."},{"type":"text","text":" "},{"type":"text","text":"Remainder and multiplication both associate with the expression to their left."},{"type":"text","text":" "},{"type":"text","text":"Think of this as adding implicit parentheses around these parts of the expression,"},{"type":"text","text":" "},{"type":"text","text":"starting from their left:"}]},{"type":"codeListing","syntax":"swift","code":["2 + ((3 % 4) * 5)"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"(3 % 4)"},{"type":"text","text":" is "},{"type":"codeVoice","code":"3"},{"type":"text","text":", so this is equivalent to:"}]},{"type":"codeListing","syntax":"swift","code":["2 + (3 * 5)"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"(3 * 5)"},{"type":"text","text":" is "},{"type":"codeVoice","code":"15"},{"type":"text","text":", so this is equivalent to:"}]},{"type":"codeListing","syntax":"swift","code":["2 + 15"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This calculation yields the final answer of "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"including a complete list of the operator precedence groups and associativity settings,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s operator precedences and associativity rules are simpler and more predictable"},{"type":"text","text":" "},{"type":"text","text":"than those found in C and Objective-C."},{"type":"text","text":" "},{"type":"text","text":"However, this means that they aren’t exactly the same as in C-based languages."},{"type":"text","text":" "},{"type":"text","text":"Be careful to ensure that operator interactions still behave in the way you intend"},{"type":"text","text":" "},{"type":"text","text":"when porting existing code to Swift."}]}],"type":"aside","name":"Note"},{"anchor":"Operator-Methods","level":2,"type":"heading","text":"Operator Methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Classes and structures can provide their own implementations of existing operators."},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"overloading"}]},{"type":"text","text":" the existing operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows how to implement"},{"type":"text","text":" "},{"type":"text","text":"the arithmetic addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") for a custom structure."},{"type":"text","text":" "},{"type":"text","text":"The arithmetic addition operator is a binary operator"},{"type":"text","text":" "},{"type":"text","text":"because it operates on two targets"},{"type":"text","text":" "},{"type":"text","text":"and it’s an infix operator because it appears between those two targets."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example defines a "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure for"},{"type":"text","text":" "},{"type":"text","text":"a two-dimensional position vector "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"followed by a definition of an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator method"}]},{"type":"text","text":" "},{"type":"text","text":"to add together instances of the "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure:"}]},{"type":"codeListing","syntax":"swift","code":["struct Vector2D {","   var x = 0.0, y = 0.0","}","","extension Vector2D {","    static func + (left: Vector2D, right: Vector2D) -> Vector2D {","       return Vector2D(x: left.x + right.x, y: left.y + right.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The operator method is defined as a type method on "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"with a method name that matches the operator to be overloaded ("},{"type":"codeVoice","code":"+"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Because addition isn’t part of the essential behavior for a vector,"},{"type":"text","text":" "},{"type":"text","text":"the type method is defined in an extension of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" "},{"type":"text","text":"rather than in the main structure declaration of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because the arithmetic addition operator is a binary operator,"},{"type":"text","text":" "},{"type":"text","text":"this operator method takes two input parameters of type "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" "},{"type":"text","text":"and returns a single output value, also of type "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this implementation, the input parameters are named "},{"type":"codeVoice","code":"left"},{"type":"text","text":" and "},{"type":"codeVoice","code":"right"},{"type":"text","text":" "},{"type":"text","text":"to represent the "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances that will be on"},{"type":"text","text":" "},{"type":"text","text":"the left side and right side of the "},{"type":"codeVoice","code":"+"},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"The method returns a new "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instance,"},{"type":"text","text":" "},{"type":"text","text":"whose "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties are"},{"type":"text","text":" "},{"type":"text","text":"initialized with the sum of the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties from"},{"type":"text","text":" "},{"type":"text","text":"the two "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances that are added together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type method"},{"type":"text","text":" "},{"type":"text","text":"can be used as an infix operator between existing "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances:"}]},{"type":"codeListing","syntax":"swift","code":["let vector = Vector2D(x: 3.0, y: 1.0)","let anotherVector = Vector2D(x: 2.0, y: 4.0)","let combinedVector = vector + anotherVector","\/\/ combinedVector is a Vector2D instance with values of (5.0, 5.0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example adds together the vectors "},{"type":"codeVoice","code":"(3.0, 1.0)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"(2.0, 4.0)"},{"type":"text","text":" "},{"type":"text","text":"to make the vector "},{"type":"codeVoice","code":"(5.0, 5.0)"},{"type":"text","text":", as illustrated below."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"vectorAddition"}]},{"anchor":"Prefix-and-Postfix-Operators","level":3,"type":"heading","text":"Prefix and Postfix Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example shown above demonstrates a custom implementation of a binary infix operator."},{"type":"text","text":" "},{"type":"text","text":"Classes and structures can also provide implementations"},{"type":"text","text":" "},{"type":"text","text":"of the standard "},{"type":"emphasis","inlineContent":[{"type":"text","text":"unary operators"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Unary operators operate on a single target."},{"type":"text","text":" "},{"type":"text","text":"They’re "},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix"}]},{"type":"text","text":" if they precede their target (such as "},{"type":"codeVoice","code":"-a"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix"}]},{"type":"text","text":" operators if they follow their target (such as "},{"type":"codeVoice","code":"b!"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You implement a prefix or postfix unary operator by writing"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" or "},{"type":"codeVoice","code":"postfix"},{"type":"text","text":" modifier"},{"type":"text","text":" "},{"type":"text","text":"before the "},{"type":"codeVoice","code":"func"},{"type":"text","text":" keyword when declaring the operator method:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D {","    static prefix func - (vector: Vector2D) -> Vector2D {","        return Vector2D(x: -vector.x, y: -vector.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above implements the unary minus operator"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"-a"},{"type":"text","text":") for "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances."},{"type":"text","text":" "},{"type":"text","text":"The unary minus operator is a prefix operator,"},{"type":"text","text":" "},{"type":"text","text":"and so this method has to be qualified with the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" modifier."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For simple numeric values, the unary minus operator converts"},{"type":"text","text":" "},{"type":"text","text":"positive numbers into their negative equivalent and vice versa."},{"type":"text","text":" "},{"type":"text","text":"The corresponding implementation for "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances"},{"type":"text","text":" "},{"type":"text","text":"performs this operation on both the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties:"}]},{"type":"codeListing","syntax":"swift","code":["let positive = Vector2D(x: 3.0, y: 4.0)","let negative = -positive","\/\/ negative is a Vector2D instance with values of (-3.0, -4.0)","let alsoPositive = -negative","\/\/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)"]},{"anchor":"Compound-Assignment-Operators","level":3,"type":"heading","text":"Compound Assignment Operators"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Compound assignment operators"}]},{"type":"text","text":" combine assignment ("},{"type":"codeVoice","code":"="},{"type":"text","text":") with another operation."},{"type":"text","text":" "},{"type":"text","text":"For example, the addition assignment operator ("},{"type":"codeVoice","code":"+="},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"combines addition and assignment into a single operation."},{"type":"text","text":" "},{"type":"text","text":"You mark a compound assignment operator’s left input parameter type as "},{"type":"codeVoice","code":"inout"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because the parameter’s value will be modified directly from within the operator method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below implements"},{"type":"text","text":" "},{"type":"text","text":"an addition assignment operator method for "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D {","    static func += (left: inout Vector2D, right: Vector2D) {","        left = left + right","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because an addition operator was defined earlier,"},{"type":"text","text":" "},{"type":"text","text":"you don’t need to reimplement the addition process here."},{"type":"text","text":" "},{"type":"text","text":"Instead, the addition assignment operator method"},{"type":"text","text":" "},{"type":"text","text":"takes advantage of the existing addition operator method,"},{"type":"text","text":" "},{"type":"text","text":"and uses it to set the left value to be the left value plus the right value:"}]},{"type":"codeListing","syntax":"swift","code":["var original = Vector2D(x: 1.0, y: 2.0)","let vectorToAdd = Vector2D(x: 3.0, y: 4.0)","original += vectorToAdd","\/\/ original now has values of (4.0, 6.0)"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It isn’t possible to overload the default"},{"type":"text","text":" "},{"type":"text","text":"assignment operator ("},{"type":"codeVoice","code":"="},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Only the compound assignment operators can be overloaded."},{"type":"text","text":" "},{"type":"text","text":"Similarly, the ternary conditional operator"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"a ? b : c"},{"type":"text","text":") can’t be overloaded."}]}],"type":"aside","name":"Note"},{"anchor":"Equivalence-Operators","level":3,"type":"heading","text":"Equivalence Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, custom classes and structures don’t have an implementation of"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"equivalence operators"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"known as the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"equal to"}]},{"type":"text","text":" operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":") and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not equal to"}]},{"type":"text","text":" operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"You usually implement the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"and use the standard library’s default implementation of the "},{"type":"codeVoice","code":"!="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"that negates the result of the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"There are two ways to implement the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator:"},{"type":"text","text":" "},{"type":"text","text":"You can implement it yourself,"},{"type":"text","text":" "},{"type":"text","text":"or for many types, you can ask Swift to synthesize"},{"type":"text","text":" "},{"type":"text","text":"an implementation for you."},{"type":"text","text":" "},{"type":"text","text":"In both cases,"},{"type":"text","text":" "},{"type":"text","text":"you add conformance to the standard library’s "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You provide an implementation of the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"in the same way as you implement other infix operators:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D: Equatable {","    static func == (left: Vector2D, right: Vector2D) -> Bool {","       return (left.x == right.x) && (left.y == right.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above implements an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"to check whether two "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances have equivalent values."},{"type":"text","text":" "},{"type":"text","text":"In the context of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"it makes sense to consider “equal” as meaning"},{"type":"text","text":" "},{"type":"text","text":"“both instances have the same "},{"type":"codeVoice","code":"x"},{"type":"text","text":" values and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" values”,"},{"type":"text","text":" "},{"type":"text","text":"and so this is the logic used by the operator implementation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now use this operator to check whether two "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let twoThree = Vector2D(x: 2.0, y: 3.0)","let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)","if twoThree == anotherTwoThree {","   print(\"These two vectors are equivalent.\")","}","\/\/ Prints \"These two vectors are equivalent.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In many simple cases, you can ask Swift"},{"type":"text","text":" "},{"type":"text","text":"to provide synthesized implementations of the equivalence operators for you,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"},{"type":"text","text":"."}]},{"anchor":"Custom-Operators","level":2,"type":"heading","text":"Custom Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can declare and implement your own "},{"type":"emphasis","inlineContent":[{"type":"text","text":"custom operators"}]},{"type":"text","text":" in addition to"},{"type":"text","text":" "},{"type":"text","text":"the standard operators provided by Swift."},{"type":"text","text":" "},{"type":"text","text":"For a list of characters that can be used to define custom operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"New operators are declared at a global level using the "},{"type":"codeVoice","code":"operator"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"and are marked with the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":", "},{"type":"codeVoice","code":"infix"},{"type":"text","text":" or "},{"type":"codeVoice","code":"postfix"},{"type":"text","text":" modifiers:"}]},{"type":"codeListing","syntax":"swift","code":["prefix operator +++"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above defines a new prefix operator called "},{"type":"codeVoice","code":"+++"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This operator doesn’t have an existing meaning in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and so it’s given its own custom meaning below in the specific context of"},{"type":"text","text":" "},{"type":"text","text":"working with "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances. For the purposes of this example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" is treated as a new “prefix doubling” operator."},{"type":"text","text":" "},{"type":"text","text":"It doubles the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" values of a "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instance,"},{"type":"text","text":" "},{"type":"text","text":"by adding the vector to itself with the addition assignment operator defined earlier."},{"type":"text","text":" "},{"type":"text","text":"To implement the "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"you add a type method called "},{"type":"codeVoice","code":"+++"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" as follows:"}]},{"type":"codeListing","syntax":"swift","code":["extension Vector2D {","   static prefix func +++ (vector: inout Vector2D) -> Vector2D {","      vector += vector","      return vector","   }","}","","var toBeDoubled = Vector2D(x: 1.0, y: 4.0)","let afterDoubling = +++toBeDoubled","\/\/ toBeDoubled now has values of (2.0, 8.0)","\/\/ afterDoubling also has values of (2.0, 8.0)"]},{"anchor":"Precedence-for-Custom-Infix-Operators","level":3,"type":"heading","text":"Precedence for Custom Infix Operators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom infix operators each belong to a precedence group."},{"type":"text","text":" "},{"type":"text","text":"A precedence group specifies an operator’s precedence relative"},{"type":"text","text":" "},{"type":"text","text":"to other infix operators, as well as the operator’s associativity."},{"type":"text","text":" "},{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedence-and-Associativity"},{"type":"text","text":" for an explanation of"},{"type":"text","text":" "},{"type":"text","text":"how these characteristics affect an infix operator’s interaction"},{"type":"text","text":" "},{"type":"text","text":"with other infix operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A custom infix operator that isn’t explicitly placed into a precedence group is"},{"type":"text","text":" "},{"type":"text","text":"given a default precedence group with a precedence immediately higher"},{"type":"text","text":" "},{"type":"text","text":"than the precedence of the ternary conditional operator."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines a new custom infix operator called "},{"type":"codeVoice","code":"+-"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which belongs to the precedence group "},{"type":"codeVoice","code":"AdditionPrecedence"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["infix operator +-: AdditionPrecedence","extension Vector2D {","   static func +- (left: Vector2D, right: Vector2D) -> Vector2D {","      return Vector2D(x: left.x + right.x, y: left.y - right.y)","   }","}","let firstVector = Vector2D(x: 1.0, y: 2.0)","let secondVector = Vector2D(x: 3.0, y: 4.0)","let plusMinusVector = firstVector +- secondVector","\/\/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This operator adds together the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" values of two vectors,"},{"type":"text","text":" "},{"type":"text","text":"and subtracts the "},{"type":"codeVoice","code":"y"},{"type":"text","text":" value of the second vector from the first."},{"type":"text","text":" "},{"type":"text","text":"Because it’s in essence an “additive” operator,"},{"type":"text","text":" "},{"type":"text","text":"it has been given the same precedence group"},{"type":"text","text":" "},{"type":"text","text":"as additive infix operators such as "},{"type":"codeVoice","code":"+"},{"type":"text","text":" and "},{"type":"codeVoice","code":"-"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"including a complete list of the operator precedence groups and associativity settings,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For more information about precedence groups and to see the syntax for"},{"type":"text","text":" "},{"type":"text","text":"defining your own operators and precedence groups,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration"},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You don’t specify a precedence when defining a prefix or postfix operator."},{"type":"text","text":" "},{"type":"text","text":"However, if you apply both a prefix and a postfix operator to the same operand,"},{"type":"text","text":" "},{"type":"text","text":"the postfix operator is applied first."}]}],"type":"aside","name":"Note"},{"anchor":"Result-Builders","level":2,"type":"heading","text":"Result Builders"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"result builder"}]},{"type":"text","text":" is a type you define"},{"type":"text","text":" "},{"type":"text","text":"that adds syntax for creating nested data,"},{"type":"text","text":" "},{"type":"text","text":"like a list or tree,"},{"type":"text","text":" "},{"type":"text","text":"in a natural, declarative way."},{"type":"text","text":" "},{"type":"text","text":"The code that uses the result builder"},{"type":"text","text":" "},{"type":"text","text":"can include ordinary Swift syntax, like "},{"type":"codeVoice","code":"if"},{"type":"text","text":"  and "},{"type":"codeVoice","code":"for"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to handle conditional or repeated pieces of data."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code below defines a few types for drawing on a single line"},{"type":"text","text":" "},{"type":"text","text":"using stars and text."}]},{"type":"codeListing","syntax":"swift","code":["protocol Drawable {","    func draw() -> String","}","struct Line: Drawable {","    var elements: [Drawable]","    func draw() -> String {","        return elements.map { $0.draw() }.joined(separator: \"\")","    }","}","struct Text: Drawable {","    var content: String","    init(_ content: String) { self.content = content }","    func draw() -> String { return content }","}","struct Space: Drawable {","    func draw() -> String { return \" \" }","}","struct Stars: Drawable {","    var length: Int","    func draw() -> String { return String(repeating: \"*\", count: length) }","}","struct AllCaps: Drawable {","    var content: Drawable","    func draw() -> String { return content.draw().uppercased() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Drawable"},{"type":"text","text":" protocol defines the requirement"},{"type":"text","text":" "},{"type":"text","text":"for something that can be drawn, like a line or shape:"},{"type":"text","text":" "},{"type":"text","text":"The type must implement a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Line"},{"type":"text","text":" structure represents a single-line drawing,"},{"type":"text","text":" "},{"type":"text","text":"and it serves the top-level container for most drawings."},{"type":"text","text":" "},{"type":"text","text":"To draw a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the structure calls "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" on each of the line’s components,"},{"type":"text","text":" "},{"type":"text","text":"and then concatenates the resulting strings into a single string."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Text"},{"type":"text","text":" structure wraps a string to make it part of a drawing."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" structure wraps and modifies another drawing,"},{"type":"text","text":" "},{"type":"text","text":"converting any text in the drawing to uppercase."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s possible to make a drawing with these types"},{"type":"text","text":" "},{"type":"text","text":"by calling their initializers:"}]},{"type":"codeListing","syntax":"swift","code":["let name: String? = \"Ravi Patel\"","let manualDrawing = Line(elements: [","     Stars(length: 3),","     Text(\"Hello\"),","     Space(),","     AllCaps(content: Text((name ?? \"World\") + \"!\")),","     Stars(length: 2),","])","print(manualDrawing.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code works, but it’s a little awkward."},{"type":"text","text":" "},{"type":"text","text":"The deeply nested parentheses after "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" are hard to read."},{"type":"text","text":" "},{"type":"text","text":"The fallback logic to use “World” when "},{"type":"codeVoice","code":"name"},{"type":"text","text":" is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" "},{"type":"text","text":"has to be done inline using the "},{"type":"codeVoice","code":"??"},{"type":"text","text":" operator,"},{"type":"text","text":" "},{"type":"text","text":"which would be difficult with anything more complex."},{"type":"text","text":" "},{"type":"text","text":"If you needed to include switches or "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops"},{"type":"text","text":" "},{"type":"text","text":"to build up part of the drawing, there’s no way to do that."},{"type":"text","text":" "},{"type":"text","text":"A result builder lets you rewrite code like this"},{"type":"text","text":" "},{"type":"text","text":"so that it looks like normal Swift code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To define a result builder,"},{"type":"text","text":" "},{"type":"text","text":"you write the "},{"type":"codeVoice","code":"@resultBuilder"},{"type":"text","text":" attribute on a type declaration."},{"type":"text","text":" "},{"type":"text","text":"For example, this code defines a result builder called "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which lets you use a declarative syntax to describe a drawing:"}]},{"type":"codeListing","syntax":"swift","code":["@resultBuilder","struct DrawingBuilder {","    static func buildBlock(_ components: Drawable...) -> Drawable {","        return Line(elements: components)","    }","    static func buildEither(first: Drawable) -> Drawable {","        return first","    }","    static func buildEither(second: Drawable) -> Drawable {","        return second","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" structure defines three methods"},{"type":"text","text":" "},{"type":"text","text":"that implement parts of the result builder syntax."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"buildBlock(_:)"},{"type":"text","text":" method adds support for"},{"type":"text","text":" "},{"type":"text","text":"writing a series of lines in a block of code."},{"type":"text","text":" "},{"type":"text","text":"It combines the components in that block into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods"},{"type":"text","text":" "},{"type":"text","text":"add support for "},{"type":"codeVoice","code":"if"},{"type":"text","text":"-"},{"type":"codeVoice","code":"else"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can apply the "},{"type":"codeVoice","code":"@DrawingBuilder"},{"type":"text","text":" attribute to a function’s parameter,"},{"type":"text","text":" "},{"type":"text","text":"which turns a closure passed to the function"},{"type":"text","text":" "},{"type":"text","text":"into the value that the result builder creates from that closure."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["func draw(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return content()","}","func caps(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return AllCaps(content: content())","}","","func makeGreeting(for name: String? = nil) -> Drawable {","    let greeting = draw {","        Stars(length: 3)","        Text(\"Hello\")","        Space()","        caps {","            if let name = name {","                Text(name + \"!\")","            } else {","                Text(\"World!\")","            }","        }","        Stars(length: 2)","    }","    return greeting","}","let genericGreeting = makeGreeting()","print(genericGreeting.draw())","\/\/ Prints \"***Hello WORLD!**\"","","let personalGreeting = makeGreeting(for: \"Ravi Patel\")","print(personalGreeting.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeGreeting(for:)"},{"type":"text","text":" function takes a "},{"type":"codeVoice","code":"name"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"type":"text","text":"and uses it to draw a personalized greeting."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"draw(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"caps(_:)"},{"type":"text","text":" functions"},{"type":"text","text":" "},{"type":"text","text":"both take a single closure as their argument,"},{"type":"text","text":" "},{"type":"text","text":"which is marked with the "},{"type":"codeVoice","code":"@DrawingBuilder"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"When you call those functions,"},{"type":"text","text":" "},{"type":"text","text":"you use the special syntax that "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" defines."},{"type":"text","text":" "},{"type":"text","text":"Swift transforms that declarative description of a drawing"},{"type":"text","text":" "},{"type":"text","text":"into a series of calls to the methods on "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" "},{"type":"text","text":"to build up the value that’s passed as the function argument."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift transforms the call to "},{"type":"codeVoice","code":"caps(_:)"},{"type":"text","text":" in that example"},{"type":"text","text":" "},{"type":"text","text":"into code like the following:"}]},{"type":"codeListing","syntax":"swift","code":["let capsDrawing = caps {","    let partialDrawing: Drawable","    if let name = name {","        let text = Text(name + \"!\")","        partialDrawing = DrawingBuilder.buildEither(first: text)","    } else {","        let text = Text(\"World!\")","        partialDrawing = DrawingBuilder.buildEither(second: text)","    }","    return partialDrawing","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift transforms the "},{"type":"codeVoice","code":"if"},{"type":"text","text":"-"},{"type":"codeVoice","code":"else"},{"type":"text","text":" block into"},{"type":"text","text":" "},{"type":"text","text":"calls to the "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods."},{"type":"text","text":" "},{"type":"text","text":"Although you don’t call these methods in your own code,"},{"type":"text","text":" "},{"type":"text","text":"showing the result of the transformation"},{"type":"text","text":" "},{"type":"text","text":"makes it easier to see how Swift transforms your code"},{"type":"text","text":" "},{"type":"text","text":"when you use the "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" syntax."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To add support for writing "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops in the special drawing syntax,"},{"type":"text","text":" "},{"type":"text","text":"add a "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method."}]},{"type":"codeListing","syntax":"swift","code":["extension DrawingBuilder {","    static func buildArray(_ components: [Drawable]) -> Drawable {","        return Line(elements: components)","    }","}","let manyStars = draw {","    Text(\"Stars:\")","    for length in 1...3 {","        Space()","        Stars(length: length)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loop creates an array of drawings,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method turns that array into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a complete list of how Swift transforms builder syntax"},{"type":"text","text":" "},{"type":"text","text":"into calls to the builder type’s methods,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"-> extension Vector3D: Equatable {"},{"type":"text","text":" "},{"type":"text","text":"static func == (left: Vector3D, right: Vector3D) -> Bool {"},{"type":"text","text":" "},{"type":"text","text":"return (left.x == right.x) && (left.y == right.y) && (left.z == right.z)"},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"}"}]},{"style":"note","content":[{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"let r0 ="},{"type":"text","text":" "},{"type":"text","text":"Vector3D(x: 1.1, y: 2.3, z: 12) == Vector3D(x: 1.1, y: 2.3, z: 12)"},{"type":"text","text":" "},{"type":"text","text":"assert(r0)"},{"type":"text","text":" "},{"type":"text","text":"}"}]}],"type":"aside","name":"Note"}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"-> extension Double {"},{"type":"text","text":" "},{"type":"text","text":"static func *** (scale: Double, vector: Vector2D) -> Vector2D {"},{"type":"text","text":" "},{"type":"text","text":"return Vector2D(x: scale * vector.x, y: scale * vector.y)"},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"-> extension Vector2D: AnotherProtocol {}"},{"type":"text","text":" "},{"type":"text","text":"-> let unitVector = Vector2D(x: 1.0, y: 1.0)"},{"type":"text","text":" "},{"type":"text","text":"-> print(2.5 *** unitVector)"},{"type":"text","text":" "},{"type":"text","text":"<- Vector2D(x: 2.5, y: 2.5)"},{"type":"text","text":" "},{"type":"text","text":"}"}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/the-swift-programming-language\/advancedoperators"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"Swift provides several advanced operators that perform more complex value manipulation."},{"type":"text","text":" "},{"type":"text","text":"These include all of the bitwise and bit shifting operators you will be familiar with"},{"type":"text","text":" "},{"type":"text","text":"from C and Objective-C."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Advanced Operators","role":"article","modules":[{"name":"The Swift Programming Language"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/TSPL"]]},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl"],"generated":true}],"references":{"doc://org.swift.tspl/documentation/TSPL":{"role":"collection","title":"The Swift Programming Language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/TSPL","kind":"symbol","type":"topic","url":"\/documentation\/tspl"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators":{"abstract":[],"title":"Bitwise Left and Right Shift Operators","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators","url":"\/documentation\/the-swift-programming-language\/advancedoperators#Bitwise-Left-and-Right-Shift-Operators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"known as arrays, sets, and dictionaries,"},{"type":"text","text":" "},{"type":"text","text":"for storing collections of values."},{"type":"text","text":" "},{"type":"text","text":"Arrays are ordered collections of values."},{"type":"text","text":" "},{"type":"text","text":"Sets are unordered collections of unique values."},{"type":"text","text":" "},{"type":"text","text":"Dictionaries are unordered collections of key-value associations."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes"},"bitshiftUnsigned":{"alt":null,"type":"image","identifier":"bitshiftUnsigned","variants":[{"url":"\/images\/bitshiftUnsigned@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftUnsigned~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures":{"role":"article","title":"Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures"},"bitshiftSignedMinusFourValue":{"alt":null,"type":"image","identifier":"bitshiftSignedMinusFourValue","variants":[{"url":"\/images\/bitshiftSignedMinusFourValue@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedMinusFourValue~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations":{"role":"article","title":"Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values"},{"type":"text","text":" "},{"type":"text","text":"and enables you to work with those values in a type-safe way within your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"role":"article","title":"Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol"}]},{"type":"text","text":" defines a blueprint of"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"type":"text","text":"The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"type":"text","text":"to provide an actual implementation of those requirements."},{"type":"text","text":" "},{"type":"text","text":"Any type that satisfies the requirements of a protocol is said to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conform"}]},{"type":"text","text":" to that protocol."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Subscripts":{"role":"article","title":"Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are shortcuts for accessing the member elements of a collection, list, or sequence."},{"type":"text","text":" "},{"type":"text","text":"You use subscripts to set and retrieve values by index without needing"},{"type":"text","text":" "},{"type":"text","text":"separate methods for setting and retrieval."},{"type":"text","text":" "},{"type":"text","text":"For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" "},{"type":"text","text":"and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Subscripts","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/subscripts"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Properties":{"role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Properties"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration."},{"type":"text","text":" "},{"type":"text","text":"Stored properties store constant and variable values as part of an instance,"},{"type":"text","text":" "},{"type":"text","text":"whereas computed properties calculate (rather than store) a value."},{"type":"text","text":" "},{"type":"text","text":"Computed properties are provided by classes, structures, and enumerations."},{"type":"text","text":" "},{"type":"text","text":"Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Properties","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/properties"},"vectorAddition":{"alt":null,"type":"image","identifier":"vectorAddition","variants":[{"url":"\/images\/vectorAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/vectorAddition~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Deinitialization":{"role":"article","title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"deinitializer"}]},{"type":"text","text":" is called immediately before a class instance is deallocated."},{"type":"text","text":" "},{"type":"text","text":"You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"type":"text","text":"similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Deinitializers are only available on class types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Deinitialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/deinitialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/NestedTypes":{"role":"article","title":"Nested Types","abstract":[{"type":"text","text":"Enumerations are often created to support a specific class or structure’s functionality."},{"type":"text","text":" "},{"type":"text","text":"Similarly, it can be convenient to define utility classes and structures"},{"type":"text","text":" "},{"type":"text","text":"purely for use within the context of a more complex type."},{"type":"text","text":" "},{"type":"text","text":"To accomplish this, Swift enables you to define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"nested types"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"whereby you nest supporting enumerations, classes, and structures"},{"type":"text","text":" "},{"type":"text","text":"within the definition of the type they support."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/nestedtypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes#resultBuilder":{"abstract":[],"title":"resultBuilder","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder","url":"\/documentation\/the-swift-programming-language\/attributes#resultBuilder"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/StringsAndCharacters":{"role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"string"}]},{"type":"text","text":" is a series of characters,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"The contents of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" can be accessed in various ways,"},{"type":"text","text":" "},{"type":"text","text":"including as a collection of "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" values."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/StringsAndCharacters","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/stringsandcharacters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"role":"article","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC)"},{"type":"text","text":" "},{"type":"text","text":"to track and manage your app’s memory usage."},{"type":"text","text":" "},{"type":"text","text":"In most cases, this means that memory management “just works” in Swift,"},{"type":"text","text":" "},{"type":"text","text":"and you don’t need to think about memory management yourself."},{"type":"text","text":" "},{"type":"text","text":"ARC automatically frees up the memory used by class instances"},{"type":"text","text":" "},{"type":"text","text":"when those instances are no longer needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting"},"bitwiseNOT":{"alt":null,"type":"image","identifier":"bitwiseNOT","variants":[{"url":"\/images\/bitwiseNOT@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseNOT~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure#Operators":{"abstract":[],"title":"Operators","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators","url":"\/documentation\/the-swift-programming-language\/lexicalstructure#Operators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"role":"article","title":"Extensions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing"},{"type":"text","text":" "},{"type":"text","text":"class, structure, enumeration, or protocol type."},{"type":"text","text":" "},{"type":"text","text":"This includes the ability to extend types"},{"type":"text","text":" "},{"type":"text","text":"for which you don’t have access to the original source code"},{"type":"text","text":" "},{"type":"text","text":"(known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Extensions are similar to categories in Objective-C."},{"type":"text","text":" "},{"type":"text","text":"(Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"bitwiseAND":{"alt":null,"type":"image","identifier":"bitwiseAND","variants":[{"url":"\/images\/bitwiseAND@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseAND~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"role":"article","title":"Concurrency","abstract":[{"type":"text","text":"Swift has built-in support for writing asynchronous and parallel code"},{"type":"text","text":" "},{"type":"text","text":"in a structured way."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"type":"text","text":" can be suspended and resumed later,"},{"type":"text","text":" "},{"type":"text","text":"although only one piece of the program executes at a time."},{"type":"text","text":" "},{"type":"text","text":"Suspending and resuming code in your program"},{"type":"text","text":" "},{"type":"text","text":"lets it continue to make progress"},{"type":"text","text":" "},{"type":"text","text":"on short-term operations like updating its UI"},{"type":"text","text":" "},{"type":"text","text":"while continuing to work on long-running operations"},{"type":"text","text":" "},{"type":"text","text":"like fetching data over the network or parsing files."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Parallel code"}]},{"type":"text","text":" means multiple pieces of code run simultaneously —"},{"type":"text","text":" "},{"type":"text","text":"for example, a computer with a four-core processor"},{"type":"text","text":" "},{"type":"text","text":"can run four pieces of code at the same time,"},{"type":"text","text":" "},{"type":"text","text":"with each core carrying out one of the tasks."},{"type":"text","text":" "},{"type":"text","text":"A program that uses parallel and asynchronous code"},{"type":"text","text":" "},{"type":"text","text":"carries out multiple operations at a time;"},{"type":"text","text":" "},{"type":"text","text":"it suspends operations that are waiting for an external system,"},{"type":"text","text":" "},{"type":"text","text":"and makes it easier to write this code in a memory-safe way."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","title":"Type Casting","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance,"},{"type":"text","text":" "},{"type":"text","text":"or to treat that instance as a different"},{"type":"text","text":" "},{"type":"text","text":"superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting"},"bitshiftSignedAddition":{"alt":null,"type":"image","identifier":"bitshiftSignedAddition","variants":[{"url":"\/images\/bitshiftSignedAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedAddition~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"role":"article","title":"Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"type":"text","text":" "},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"type":"text","text":" "},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"role":"article","title":"Optional Chaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling"},{"type":"text","text":" "},{"type":"text","text":"properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the optional contains a value,"},{"type":"text","text":" "},{"type":"text","text":"the property, method, or subscript call succeeds;"},{"type":"text","text":" "},{"type":"text","text":"if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Multiple queries can be chained together,"},{"type":"text","text":" "},{"type":"text","text":"and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/optionalchaining"},"bitwiseXOR":{"alt":null,"type":"image","identifier":"bitwiseXOR","variants":[{"url":"\/images\/bitwiseXOR@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseXOR~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"role":"article","title":"Control Flow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements."},{"type":"text","text":" "},{"type":"text","text":"These include "},{"type":"codeVoice","code":"while"},{"type":"text","text":" loops to perform a task multiple times;"},{"type":"text","text":" "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements"},{"type":"text","text":" "},{"type":"text","text":"to execute different branches of code based on certain conditions;"},{"type":"text","text":" "},{"type":"text","text":"and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" "},{"type":"text","text":"to transfer the flow of execution to another point in your code."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/controlflow"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task."},{"type":"text","text":" "},{"type":"text","text":"You give a function a name that identifies what it does,"},{"type":"text","text":" "},{"type":"text","text":"and this name is used to “call” the function to perform its task when needed."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods":{"role":"article","title":"Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can all define instance methods,"},{"type":"text","text":" "},{"type":"text","text":"which encapsulate specific tasks and functionality for working with an instance of a given type."},{"type":"text","text":" "},{"type":"text","text":"Classes, structures, and enumerations can also define type methods,"},{"type":"text","text":" "},{"type":"text","text":"which are associated with the type itself."},{"type":"text","text":" "},{"type":"text","text":"Type methods are similar to class methods in Objective-C."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/methods"},"bitwiseOR":{"alt":null,"type":"image","identifier":"bitwiseOR","variants":[{"url":"\/images\/bitwiseOR@2x.png","traits":["2x","light"]},{"url":"\/images\/bitwiseOR~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Operator-Declaration":{"abstract":[],"title":"Operator Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Operator-Declaration"},"overflowAddition":{"alt":null,"type":"image","identifier":"overflowAddition","variants":[{"url":"\/images\/overflowAddition@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowAddition~dark@2x.png","traits":["2x","dark"]}]},"bitshiftSignedFour":{"alt":null,"type":"image","identifier":"bitshiftSignedFour","variants":[{"url":"\/images\/bitshiftSignedFour@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedFour~dark@2x.png","traits":["2x","dark"]}]},"bitshiftSigned":{"alt":null,"type":"image","identifier":"bitshiftSigned","variants":[{"url":"\/images\/bitshiftSigned@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSigned~dark@2x.png","traits":["2x","dark"]}]},"overflowUnsignedSubtraction":{"alt":null,"type":"image","identifier":"overflowUnsignedSubtraction","variants":[{"url":"\/images\/overflowUnsignedSubtraction@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowUnsignedSubtraction~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation":{"abstract":[],"title":"Adopting a Protocol Using a Synthesized Implementation","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation","url":"\/documentation\/the-swift-programming-language\/protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"},"https://developer.apple.com/documentation/swift/operator_declarations":{"title":"Operator Declarations","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"role":"article","title":"Memory Safety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"Swift ensures that variables are initialized before they’re used,"},{"type":"text","text":" "},{"type":"text","text":"memory isn’t accessed after it’s been deallocated,"},{"type":"text","text":" "},{"type":"text","text":"and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/memorysafety"},"overflowSignedSubtraction":{"alt":null,"type":"image","identifier":"overflowSignedSubtraction","variants":[{"url":"\/images\/overflowSignedSubtraction@2x.png","traits":["2x","light"]},{"url":"\/images\/overflowSignedSubtraction~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"role":"article","title":"Inheritance","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" methods, properties, and other characteristics"},{"type":"text","text":" "},{"type":"text","text":"from another class."},{"type":"text","text":" "},{"type":"text","text":"When one class inherits from another,"},{"type":"text","text":" "},{"type":"text","text":"the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Inheritance is a fundamental behavior that differentiates classes"},{"type":"text","text":" "},{"type":"text","text":"from other types in Swift."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/inheritance"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AccessControl":{"role":"article","title":"Access Control","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"type":"text","text":" restricts access to parts of your code"},{"type":"text","text":" "},{"type":"text","text":"from code in other source files and modules."},{"type":"text","text":" "},{"type":"text","text":"This feature enables you to hide the implementation details of your code,"},{"type":"text","text":" "},{"type":"text","text":"and to specify a preferred interface through which that code can be accessed and used."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AccessControl","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/accesscontrol"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Precedence-and-Associativity":{"abstract":[],"title":"Precedence and Associativity","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedence-and-Associativity","url":"\/documentation\/the-swift-programming-language\/advancedoperators#Precedence-and-Associativity"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"role":"article","title":"Opaque Types","abstract":[{"type":"text","text":"A function or method with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."},{"type":"text","text":" "},{"type":"text","text":"Unlike returning a value whose type is a protocol type,"},{"type":"text","text":" "},{"type":"text","text":"opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization":{"role":"article","title":"Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of"},{"type":"text","text":" "},{"type":"text","text":"a class, structure, or enumeration for use."},{"type":"text","text":" "},{"type":"text","text":"This process involves setting an initial value for each stored property on that instance"},{"type":"text","text":" "},{"type":"text","text":"and performing any other setup or initialization that’s required"},{"type":"text","text":" "},{"type":"text","text":"before the new instance is ready for use."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures":{"role":"article","title":"Structures and Classes","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" are general-purpose,"},{"type":"text","text":" "},{"type":"text","text":"flexible constructs that become the building blocks of your program’s code."},{"type":"text","text":" "},{"type":"text","text":"You define properties and methods to add functionality to your structures and classes"},{"type":"text","text":" "},{"type":"text","text":"using the same syntax you use to define constants, variables, and functions."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/classesandstructures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to"},{"type":"text","text":" "},{"type":"text","text":"and recovering from error conditions in your program."},{"type":"text","text":" "},{"type":"text","text":"Swift provides first-class support for"},{"type":"text","text":" "},{"type":"text","text":"throwing, catching, propagating, and manipulating"},{"type":"text","text":" "},{"type":"text","text":"recoverable errors at runtime."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/errorhandling"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"role":"article","title":"Basic Operators","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]},{"type":"text","text":" is a special symbol or phrase that you use to"},{"type":"text","text":" "},{"type":"text","text":"check, change, or combine values."},{"type":"text","text":" "},{"type":"text","text":"For example, the addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") adds two numbers,"},{"type":"text","text":" "},{"type":"text","text":"as in "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values,"},{"type":"text","text":" "},{"type":"text","text":"as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics":{"role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a programming language for iOS, macOS, watchOS, and tvOS app development."},{"type":"text","text":" "},{"type":"text","text":"If you have experience developing in C or Objective-C,"},{"type":"text","text":" "},{"type":"text","text":"many parts of Swift will be familiar to you."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/thebasics"},"bitshiftSignedMinusFour":{"alt":null,"type":"image","identifier":"bitshiftSignedMinusFour","variants":[{"url":"\/images\/bitshiftSignedMinusFour@2x.png","traits":["2x","light"]},{"url":"\/images\/bitshiftSignedMinusFour~dark@2x.png","traits":["2x","dark"]}]}}}